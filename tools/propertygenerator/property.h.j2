{#
SPDX-License-Identifier: LGPL-2.1-only OR LGPL-3.0-only OR LicenseRef-KDE-Accepted-LGPL
SPDX-FileCopyrightText: 2024 Arjen Hiemstra <ahiemstra@heimr.nl>

This is the template that is used to generate property class headers. It uses Jinja 2 syntax.
#}
// SPDX-License-Identifier: LGPL-2.1-only OR LGPL-3.0-only OR LicenseRef-KDE-Accepted-LGPL
//
// This file is automatically generated. To regenerate, run `tools/propertygenerator/generate_properties.py`.

#pragma once

{#
The include list may contain extra newlines that are hard to get rid of with the
template but that clang format doesn't like, so disable format for that.
#}
// clang-format off

#include <QDebug>

{% for include in system_includes | sort %}
#include <{{ include }}>
{% endfor %}

{% for include in local_includes | sort %}
#include "{{ include }}"
{% endfor %}

#include "union_export.h"

// clang-format on

namespace Union
{
namespace Properties
{

class {{ type_name }}Private;

class UNION_EXPORT {{ type_name }}
{
public:
    {{ type_name }}();
    {{ type_name }}(const {{ type_name }} &other);
    {{ type_name }}({{ type_name }} &&other);
    ~{{ type_name }}();

    {{ type_name }} &operator=(const {{ type_name }} &other);
    {{ type_name }} &operator=({{ type_name }} &&other);

{% for value in values %}
    std::optional<{{ value.type }}> {{ value.name }}() const;
    void set{{ value.name | ucfirst }}(const std::optional<{{ value.type }}> &newValue);

{% endfor %}
    /**
     * Check if this property has any value set.
     *
     * Note that for any sub property that this property has, it also checks if
     * that sub-property has any value.
     */
    bool hasAnyValue() const;

    /**
     * Copy values from source to destination if destination does not have a value.
     *
     * This will recursively copy sub-values.
     *
     * \param source The source property to copy from.
     * \param destination The destination property to copy to.
     */
    static void resolveProperties(const {{ type_name }} &source, {{ type_name }} &destination);

private:
    std::unique_ptr<{{ type_name }}Private> d;
};

UNION_EXPORT bool operator==(const {{ type_name }} &left, const {{ type_name}} &right);
UNION_EXPORT inline bool operator!=(const {{ type_name }} &left, const {{ type_name}} &right)
{
    return !(left == right);
}

}
}

UNION_EXPORT QDebug operator<<(QDebug debug, const Union::Properties::{{ type_name }} &type);
