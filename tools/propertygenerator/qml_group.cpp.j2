{#
SPDX-License-Identifier: LGPL-2.1-only OR LGPL-3.0-only OR LicenseRef-KDE-Accepted-LGPL
SPDX-FileCopyrightText: 2024 Arjen Hiemstra <ahiemstra@heimr.nl>

This is the template that is used to generate grouped property implementations for the QtQuick output plugin.
#}
// SPDX-License-Identifier: LGPL-2.1-only OR LGPL-3.0-only OR LicenseRef-KDE-Accepted-LGPL
//
// This file is automatically generated. To regenerate, run `tools/propertygenerator/generate_properties.py`.

{% set group_name = type_name + "Group" %}
#include "{{ group_name }}.h"

using namespace Union::Properties;
using namespace Qt::StringLiterals;

{{ group_name }}::{{ group_name }}()
{
{% for value in values %}
{% if value.is_property %}
    m_{{ value.name }} = std::make_unique<{{ value.type }}Group>();
{% endif %}
{% endfor %}
}

void {{ group_name }}::update(const {{ type_name }} &newState)
{
    m_state = newState;
{% for value in values %}
{% if value.is_property %}
    m_{{ value.name }}->update(newState.{{ value.name }}().value_or({{ value.type }}{}));
{% else %}
    Q_EMIT {{ value.name }}Changed();
{% endif %}
{% endfor %}

{% if extra_code and "update" in extra_code %}
{{ extra_code["update"] | render }}
{% endif %}
    Q_EMIT updated();
}

{% for value in values %}
{% if value.is_property %}
{{ value.type }}Group *{{ group_name }}::{{ value.name }}() const
{
    return m_{{ value.name }}.get();
}

{% else %}
{{ value.type }} {{ group_name }}::{{ value.name }}() const
{
    return m_state.{{ value.name }}().value_or({{ value.type }}{});
}

{% endif %}
{% endfor %}
{% if extra_code and "global" in extra_code %}
{{ extra_code["global"] | render }}

{% endif %}
#include "moc_{{ type_name }}Group.cpp"
