{#
SPDX-License-Identifier: LGPL-2.1-only OR LGPL-3.0-only OR LicenseRef-KDE-Accepted-LGPL
SPDX-FileCopyrightText: 2024 Arjen Hiemstra <ahiemstra@heimr.nl>

This is the template that is used to generate helper functions for tests.

REUSE-IgnoreStart
#}
// SPDX-License-Identifier: LGPL-2.1-only OR LGPL-3.0-only OR LicenseRef-KDE-Accepted-LGPL
// SPDX-FileCopyrightText: 2024 Arjen Hiemstra <ahiemstra@heimr.nl>
//
// This file is automatically generated from CreateTestInstances.h.j2.
// To regenerate, run `tools/propertygenerator/generate_properties.py`.
{# REUSE-IgnoreEnd #}

#pragma once

#include <QtTest>

{% for type in types | sort %}
#include <properties/{{ type.type_name }}.h>
{% endfor %}

using namespace Qt::StringLiterals;

namespace Union
{
namespace Properties
{

QColor testQColorInstance()
{
    return Qt::magenta;
}

qreal testQrealInstance()
{
    return 10.0;
}

QFont testQFontInstance()
{
    return QFont{u"Noto Sans"_s, 12};
}

{% for type in types %}
std::unique_ptr<{{ type.type_name }}> test{{ type.type_name }}Instance();
{% endfor %}
{% for type in types %}

std::unique_ptr<{{ type.type_name }}> test{{type.type_name}}Instance()
{
    auto instance = std::make_unique<{{ type.type_name }}>();

{% for property in type.properties %}
{% if property.is_group %}
    instance->set{{ property.name | ucfirst }}(test{{ property.type }}Instance());
{% elif property.type == "QColor" %}
    instance->set{{ property.name | ucfirst }}(testQColorInstance());
{% elif property.type == "qreal" %}
    instance->set{{ property.name | ucfirst }}(testQrealInstance());
{% elif property.type == "QFont" %}
    instance->set{{ property.name | ucfirst }}(testQFontInstance());
{% else %}
    instance->set{{ property.name | ucfirst }}({{ property.type }}{});
{% endif %}
{% endfor %}

    return instance;
}
{% endfor %}
}
}
