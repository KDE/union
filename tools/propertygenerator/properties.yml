palette:
    accent: QColor
    alternateBase: QColor
    base: QColor
    brightText: QColor
    button: QColor
    buttonText: QColor
    dark: QColor
    highlight: QColor
    highlightedText: QColor
    light: QColor
    link: QColor
    linkVisited: QColor
    mid: QColor
    midlight: QColor
    placeholderText: QColor
    shadow: QColor
    text: QColor
    toolTipBase: QColor
    toolTipText: QColor
    window: QColor
    windowText: QColor
    positive: QColor
    neutral: QColor
    negative: QColor

    _extra_system_includes:
        "qml_group.h.j2":
        -   "QVariant"
        -   "QQmlComponent"
    _extra_code:
        "qml_group.h.j2":
            public: |4
                    Q_PROPERTY(QObject *quickPalette READ quickPalette NOTIFY updated)
                    QObject *quickPalette() const;

            private: |4
                    QObject *m_palette = nullptr;
                    QQmlComponent *m_component = nullptr;

        "qml_group.cpp.j2":
            update: |4
                    if (!m_component) {
                        // We need a QML engine to create a QQmlComponent. Try to determine it
                        // based on the style we're part of.
                        Q_ASSERT(m_style);
                        m_component = new QQmlComponent(m_style->engine());
                        m_component->setData("import QtQuick; Palette { }"_ba, QUrl{});
                    }

                    if (m_palette) {
                        delete m_palette;
                    }

                    m_palette = m_component->create();
                    {% for value in values %}
                    {% if value.name not in ["positive", "neutral", "negative"] %}

                    if (m_state.{{ value.name }}()) {
                        m_palette->setProperty("{{ value.name }}", QVariant::fromValue(m_state.{{ value.name }}().value()));
                    }
                    {% endif %}
                    {% endfor %}

            global: |
                QObject *{{ type_name }}Group::quickPalette() const
                {
                    return m_palette;
                }

layout:
    alignment: &alignment
        container: Union::Properties::AlignmentContainer
        horizontal: Union::Properties::Alignment
        vertical: Union::Properties::Alignment
        order: int

    width: qreal
    height: qreal
    spacing: qreal

    padding: &size
        left: qreal
        right: qreal
        top: qreal
        bottom: qreal

        _extra_system_includes:
            "property.h.j2":
            -   "QMarginsF"
        _extra_code:
            "property.h.j2":
                public: |4
                        /*!
                           Convert a Size property to QMarginsF.

                           If any values are not set, they will use 0.0.
                         */
                        QMarginsF toMargins() const;
            "property.cpp.j2":
                global: |4
                    QMarginsF {{ type_name }}::toMargins() const
                    {
                        return QMarginsF{d->left.value_or(0.0), d->top.value_or(0.0), d->right.value_or(0.0), d->bottom.value_or(0.0)};
                    }

    inset: *size

    margins: *size

text:
    alignment: *alignment
    font: QFont

icon:
    alignment: *alignment
    width: qreal
    height: qreal
    name: QString
    source: QUrl

background:
    color: QColor
    image: &image
        imageData: QImage
        width: qreal
        height: qreal
        xOffset: qreal
        yOffset: qreal
        flags: Union::Properties::ImageFlags

    border:
        left: &line
            size: qreal
            color: QColor
            style: Union::Properties::LineStyle
            image: *image

        right: *line
        top: *line
        bottom: *line

    corners:
        topLeft: &corner
            radius: qreal
            width: qreal
            height: qreal
            color: QColor
            image: *image

        topRight: *corner
        bottomLeft: *corner
        bottomRight: *corner

    shadow:
        offsets: *size

        left: *line
        right: *line
        top: *line
        bottom: *line

        topLeft: *corner
        topRight: *corner
        bottomLeft: *corner
        bottomRight: *corner
