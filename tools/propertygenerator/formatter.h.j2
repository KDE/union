{#
SPDX-License-Identifier: LGPL-2.1-only OR LGPL-3.0-only OR LicenseRef-KDE-Accepted-LGPL
SPDX-FileCopyrightText: 2024 Arjen Hiemstra <ahiemstra@heimr.nl>

This is the template that is used to generate std::formatter support for property classes.

REUSE-IgnoreStart
#}
// SPDX-License-Identifier: LGPL-2.1-only OR LGPL-3.0-only OR LicenseRef-KDE-Accepted-LGPL
// SPDX-FileCopyrightText: 2024 Arjen Hiemstra <ahiemstra@heimr.nl>
//
// This file is automatically generated from formatter.h.j2.
// To regenerate, run `tools/propertygenerator/generate_properties.py`.
{# REUSE-IgnoreEnd #}

#pragma once

#include <format>

{% for type in types | sort %}
#include <properties/{{ type.type_name }}.h>
{% endfor %}

namespace
{
inline static std::string whitespace(std::size_t(1024), ' ');
}

std::string_view indent(int amount)
{
    return std::string_view(whitespace.begin(), whitespace.begin() + amount);
}

template<typename T>
struct std::formatter<std::optional<T>, char> {
    std::string content_format;

    template<class ParseContext>
    constexpr ParseContext::iterator parse(ParseContext &context)
    {
        auto itr = context.begin();
        while (itr != context.end() && *itr != '}') {
            itr++;
        }
        content_format = std::string(context.begin(), itr);
        return itr;
    }

    template<class FormatContext>
    FormatContext::iterator format(const std::optional<T> &value, FormatContext &context) const
    {
        if (value.has_value()) {
            return std::vformat_to(context.out(), "{0:" + content_format + "}", std::make_format_args(value.value()));
        } else {
            return std::ranges::copy("(empty)", context.out()).out;
        }
    }
};

template<>
struct std::formatter<QColor, char> : public std::formatter<std::string, char> {
    template<class FormatContext>
    FormatContext::iterator format(QColor value, FormatContext &context) const
    {
        return std::formatter<std::string, char>::format(value.name().toStdString(), context);
    }
};

template<>
struct std::formatter<QFont, char> : public std::formatter<std::string, char> {
    template<class FormatContext>
    FormatContext::iterator format(QFont value, FormatContext &context) const
    {
        return std::formatter<std::string, char>::format(value.toString().toStdString(), context);
    }
};

template<>
struct std::formatter<QString, char> : public std::formatter<std::string, char> {
    template<class FormatContext>
    FormatContext::iterator format(QString value, FormatContext &context) const
    {
        return std::formatter<std::string, char>::format(value.toStdString(), context);
    }
};

template<>
struct std::formatter<QUrl, char> : public std::formatter<std::string, char> {
    template<class FormatContext>
    FormatContext::iterator format(QUrl value, FormatContext &context) const
    {
        return std::formatter<std::string, char>::format(value.toString().toStdString(), context);
    }
};

template<>
struct std::formatter<QImage, char> : public std::formatter<std::string, char> {
    template<class FormatContext>
    FormatContext::iterator format(QImage value, FormatContext &context) const
    {
        auto metaEnum = QMetaEnum::fromType<QImage::Format>();
        auto tmp = std::format("QImage(fmt={0}, width={1}, height={2})", metaEnum.valueToKey(value.format()), value.width(), value.height());
        return std::formatter<std::string, char>::format(tmp, context);
    }
};

template<>
struct std::formatter<Qt::Alignment, char> : public std::formatter<std::string, char> {
    template<class FormatContext>
    FormatContext::iterator format(Qt::Alignment value, FormatContext &context) const
    {
        auto metaEnum = QMetaEnum::fromType<Qt::Alignment>();
        return std::formatter<std::string, char>::format(metaEnum.valueToKeys(value).toStdString(), context);
    }
};

template<typename T>
    requires std::is_enum_v<T>
struct std::formatter<T, char> : public std::formatter<std::string, char> {
    template<class FormatContext>
    FormatContext::iterator format(T value, FormatContext &context) const
    {
        auto metaEnum = QMetaEnum::fromType<T>();
        return std::formatter<std::string, char>::format(metaEnum.valueToKey(int(value)), context);
    }
};

template<typename T>
    requires std::is_enum_v<T>
struct std::formatter<QFlags<T>, char> : public std::formatter<std::string, char> {
    template<class FormatContext>
    FormatContext::iterator format(const QFlags<T> value, FormatContext &context) const
    {
        auto metaEnum = QMetaEnum::fromType<T>();
        return std::formatter<std::string, char>::format(metaEnum.valueToKeys(value).toStdString(), context);
    }
};

{% for type in types %}
template<>
struct std::formatter<Union::Properties::{{ type.type_name }}, char> {
    bool use_newlines = false;
    int indentation = 0;

    template<class ParseContext>
    constexpr ParseContext::iterator parse(ParseContext &context)
    {
        std::string digits;

        auto itr = context.begin();
        while (itr != context.end() && *itr != '}') {
            if (*itr == 'n' && *(itr + 1) == 'l') {
                use_newlines = true;
            }

            if (*itr >= 48 && *itr <= 57) {
                indentation = indentation * 10 + (*itr - 48);
            }

            itr++;
        }

        return itr;
    }

    template<class FormatContext>
    FormatContext::iterator format(const Union::Properties::{{ type.type_name }} &property, FormatContext &context) const
    {
        std::ostringstream out;

{% for value in type.values %}
        out << indent(indentation);
        out << "{{ value.name }}: ";
        {
            auto value = property.{{ value.name }}();
            if (use_newlines) {
{% if value.is_property %}
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
{% else %}
                out << std::format("{}\n", value);
{% endif %}
            } else {
                out << std::format("{} ", value);
            }
        }

{% endfor %}
        return std::ranges::copy(std::move(out).str(), context.out()).out;
    }
};

{% endfor %}
//
