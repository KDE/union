{#
SPDX-License-Identifier: LGPL-2.1-only OR LGPL-3.0-only OR LicenseRef-KDE-Accepted-LGPL
SPDX-FileCopyrightText: 2024 Arjen Hiemstra <ahiemstra@heimr.nl>

This is the template that is used to generate property class implementations. It uses Jinja 2 syntax.
#}
// SPDX-License-Identifier: LGPL-2.1-only OR LGPL-3.0-only OR LicenseRef-KDE-Accepted-LGPL
//
// This file is automatically generated. To regenerate, run `generate_properties.py`.

#include "{{ type_name }}.h"

using namespace Union::Properties;
using namespace Qt::StringLiterals;

class Union::Properties::{{ type_name }}Private
{
public:
{% for value in values %}
    std::optional<{{ value.type }}> {{ value.name }};
{% endfor %}
};

{{ type_name }}::{{ type_name }}()
    : d(std::make_unique<{{ type_name }}Private>())
{
}

{{ type_name }}::{{ type_name }}(const {{ type_name }} &other)
    : d(std::make_unique<{{ type_name }}Private>())
{
{% for value in values %}
    d->{{ value.name }} = other.d->{{ value.name }};
{% endfor %}
}

{{ type_name }}::{{ type_name }}({{ type_name }} &&other)
    : d(std::move(other.d))
{
}

{{ type_name }}::~{{ type_name}}() = default;

{{ type_name }} &{{ type_name }}::operator=(const {{ type_name }} &other)
{
    if (this != &other) {
{% for value in values %}
        d->{{ value.name }} = other.d->{{ value.name }};
{% endfor %}
    }
    return *this;
}

{{ type_name }} &{{ type_name }}::operator=({{ type_name }} &&other)
{
    std::swap(d, other.d);
    return *this;
}

{% for value in values %}
std::optional<{{ value.type }}> {{ type_name }}::{{ value.name }}() const
{
    return d->{{ value.name }};
}

void {{ type_name }}::set{{ value.name | ucfirst }}(const std::optional<{{ value.type }}> &newValue)
{
    if (newValue == d->{{ value.name }}) {
        return;
    }

    d->{{ value.name }} = newValue;
}
{% endfor %}

bool {{ type_name }}::hasAnyValue() const
{
{% for value in values %}
{% if value.is_property %}
    if (d->{{ value.name }}.has_value() && d->{{ value.name }}->hasAnyValue()) {
        return true;
    }
{% else %}
    if (d->{{ value.name }}.has_value()) {
        return true;
    }
{% endif %}
{% endfor %}
    return false;
}

void {{ type_name }}::resolveProperties(const {{ type_name }} &source, {{ type_name }} &destination)
{
{% for value in values %}
{% if value.is_property %}
    if (source.d->{{ value.name }}.has_value()) {
        {{ value.type }} value;
        if (destination.d->{{ value.name }}.has_value()) {
            value = destination.d->{{ value.name }}.value();
        }
        {{ value.type }}::resolveProperties(source.d->{{ value.name }}.value(), value);
        if (value.hasAnyValue()) {
            destination.d->{{ value.name }} = value;
        }
    }
{% else %}
    if (!destination.d->{{ value.name }}.has_value()) {
        destination.d->{{ value.name }} = source.d->{{ value.name }};
    }
{% endif %}
{% endfor %}
}

bool Union::Properties::operator==(const {{ type_name }} &left, const {{ type_name}} &right)
{
{% for value in values %}
    if (left.{{ value.name }}() != right.{{ value.name }}()) {
        return false;
    }
{% endfor %}
    return true;
}

QDebug operator<<(QDebug debug, const Union::Properties::{{ type_name }} &type)
{
    QDebugStateSaver saver(debug);
    debug << "{{ type_name }}(";
{% for value in values %}
    debug << "  {{value.name}}:" << type.{{ value.name }}();
{% endfor %}
    debug << ")";
    return debug;
}
