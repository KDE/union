// SPDX-License-Identifier: LGPL-2.1-only OR LGPL-3.0-only OR LicenseRef-KDE-Accepted-LGPL
// SPDX-FileCopyrightText: 2024 Arjen Hiemstra <ahiemstra@heimr.nl>
//
// This file is automatically generated from property.cpp.j2.
// To regenerate, run `tools/propertygenerator/generate_properties.py`.

#include "ShadowProperty.h"

#include "PropertiesTypes.h"

using namespace Union::Properties;
using namespace Qt::StringLiterals;

class Union::Properties::ShadowPropertyPrivate
{
public:
    std::optional<SizeProperty> offsets;
    std::optional<LineProperty> left;
    std::optional<LineProperty> right;
    std::optional<LineProperty> top;
    std::optional<LineProperty> bottom;
    std::optional<CornerProperty> topLeft;
    std::optional<CornerProperty> topRight;
    std::optional<CornerProperty> bottomLeft;
    std::optional<CornerProperty> bottomRight;
};

ShadowProperty::ShadowProperty()
    : d(std::make_unique<ShadowPropertyPrivate>())
{
}

ShadowProperty::ShadowProperty(const ShadowProperty &other)
    : d(std::make_unique<ShadowPropertyPrivate>())
{
    d->offsets = other.d->offsets;
    d->left = other.d->left;
    d->right = other.d->right;
    d->top = other.d->top;
    d->bottom = other.d->bottom;
    d->topLeft = other.d->topLeft;
    d->topRight = other.d->topRight;
    d->bottomLeft = other.d->bottomLeft;
    d->bottomRight = other.d->bottomRight;
}

ShadowProperty::ShadowProperty(ShadowProperty &&other)
    : d(std::move(other.d))
{
}

ShadowProperty::~ShadowProperty() = default;

ShadowProperty &ShadowProperty::operator=(const ShadowProperty &other)
{
    if (this != &other) {
        d->offsets = other.d->offsets;
        d->left = other.d->left;
        d->right = other.d->right;
        d->top = other.d->top;
        d->bottom = other.d->bottom;
        d->topLeft = other.d->topLeft;
        d->topRight = other.d->topRight;
        d->bottomLeft = other.d->bottomLeft;
        d->bottomRight = other.d->bottomRight;
    }
    return *this;
}

ShadowProperty &ShadowProperty::operator=(ShadowProperty &&other)
{
    std::swap(d, other.d);
    return *this;
}

std::optional<SizeProperty> ShadowProperty::offsets() const
{
    return d->offsets;
}

void ShadowProperty::setOffsets(const std::optional<SizeProperty> &newValue)
{
    if (newValue == d->offsets) {
        return;
    }

    d->offsets = newValue;
}
std::optional<LineProperty> ShadowProperty::left() const
{
    return d->left;
}

void ShadowProperty::setLeft(const std::optional<LineProperty> &newValue)
{
    if (newValue == d->left) {
        return;
    }

    d->left = newValue;
}
std::optional<LineProperty> ShadowProperty::right() const
{
    return d->right;
}

void ShadowProperty::setRight(const std::optional<LineProperty> &newValue)
{
    if (newValue == d->right) {
        return;
    }

    d->right = newValue;
}
std::optional<LineProperty> ShadowProperty::top() const
{
    return d->top;
}

void ShadowProperty::setTop(const std::optional<LineProperty> &newValue)
{
    if (newValue == d->top) {
        return;
    }

    d->top = newValue;
}
std::optional<LineProperty> ShadowProperty::bottom() const
{
    return d->bottom;
}

void ShadowProperty::setBottom(const std::optional<LineProperty> &newValue)
{
    if (newValue == d->bottom) {
        return;
    }

    d->bottom = newValue;
}
std::optional<CornerProperty> ShadowProperty::topLeft() const
{
    return d->topLeft;
}

void ShadowProperty::setTopLeft(const std::optional<CornerProperty> &newValue)
{
    if (newValue == d->topLeft) {
        return;
    }

    d->topLeft = newValue;
}
std::optional<CornerProperty> ShadowProperty::topRight() const
{
    return d->topRight;
}

void ShadowProperty::setTopRight(const std::optional<CornerProperty> &newValue)
{
    if (newValue == d->topRight) {
        return;
    }

    d->topRight = newValue;
}
std::optional<CornerProperty> ShadowProperty::bottomLeft() const
{
    return d->bottomLeft;
}

void ShadowProperty::setBottomLeft(const std::optional<CornerProperty> &newValue)
{
    if (newValue == d->bottomLeft) {
        return;
    }

    d->bottomLeft = newValue;
}
std::optional<CornerProperty> ShadowProperty::bottomRight() const
{
    return d->bottomRight;
}

void ShadowProperty::setBottomRight(const std::optional<CornerProperty> &newValue)
{
    if (newValue == d->bottomRight) {
        return;
    }

    d->bottomRight = newValue;
}

bool ShadowProperty::hasAnyValue() const
{
    if (d->offsets.has_value() && d->offsets->hasAnyValue()) {
        return true;
    }
    if (d->left.has_value() && d->left->hasAnyValue()) {
        return true;
    }
    if (d->right.has_value() && d->right->hasAnyValue()) {
        return true;
    }
    if (d->top.has_value() && d->top->hasAnyValue()) {
        return true;
    }
    if (d->bottom.has_value() && d->bottom->hasAnyValue()) {
        return true;
    }
    if (d->topLeft.has_value() && d->topLeft->hasAnyValue()) {
        return true;
    }
    if (d->topRight.has_value() && d->topRight->hasAnyValue()) {
        return true;
    }
    if (d->bottomLeft.has_value() && d->bottomLeft->hasAnyValue()) {
        return true;
    }
    if (d->bottomRight.has_value() && d->bottomRight->hasAnyValue()) {
        return true;
    }
    return false;
}

void ShadowProperty::resolveProperties(const ShadowProperty &source, ShadowProperty &destination)
{
    if (source.d->offsets.has_value()) {
        SizeProperty property;
        if (destination.d->offsets.has_value()) {
            property = destination.d->offsets.value();
        }
        SizeProperty::resolveProperties(source.d->offsets.value(), property);
        if (property.hasAnyValue()) {
            destination.d->offsets = property;
        }
    }
    if (source.d->left.has_value()) {
        LineProperty property;
        if (destination.d->left.has_value()) {
            property = destination.d->left.value();
        }
        LineProperty::resolveProperties(source.d->left.value(), property);
        if (property.hasAnyValue()) {
            destination.d->left = property;
        }
    }
    if (source.d->right.has_value()) {
        LineProperty property;
        if (destination.d->right.has_value()) {
            property = destination.d->right.value();
        }
        LineProperty::resolveProperties(source.d->right.value(), property);
        if (property.hasAnyValue()) {
            destination.d->right = property;
        }
    }
    if (source.d->top.has_value()) {
        LineProperty property;
        if (destination.d->top.has_value()) {
            property = destination.d->top.value();
        }
        LineProperty::resolveProperties(source.d->top.value(), property);
        if (property.hasAnyValue()) {
            destination.d->top = property;
        }
    }
    if (source.d->bottom.has_value()) {
        LineProperty property;
        if (destination.d->bottom.has_value()) {
            property = destination.d->bottom.value();
        }
        LineProperty::resolveProperties(source.d->bottom.value(), property);
        if (property.hasAnyValue()) {
            destination.d->bottom = property;
        }
    }
    if (source.d->topLeft.has_value()) {
        CornerProperty property;
        if (destination.d->topLeft.has_value()) {
            property = destination.d->topLeft.value();
        }
        CornerProperty::resolveProperties(source.d->topLeft.value(), property);
        if (property.hasAnyValue()) {
            destination.d->topLeft = property;
        }
    }
    if (source.d->topRight.has_value()) {
        CornerProperty property;
        if (destination.d->topRight.has_value()) {
            property = destination.d->topRight.value();
        }
        CornerProperty::resolveProperties(source.d->topRight.value(), property);
        if (property.hasAnyValue()) {
            destination.d->topRight = property;
        }
    }
    if (source.d->bottomLeft.has_value()) {
        CornerProperty property;
        if (destination.d->bottomLeft.has_value()) {
            property = destination.d->bottomLeft.value();
        }
        CornerProperty::resolveProperties(source.d->bottomLeft.value(), property);
        if (property.hasAnyValue()) {
            destination.d->bottomLeft = property;
        }
    }
    if (source.d->bottomRight.has_value()) {
        CornerProperty property;
        if (destination.d->bottomRight.has_value()) {
            property = destination.d->bottomRight.value();
        }
        CornerProperty::resolveProperties(source.d->bottomRight.value(), property);
        if (property.hasAnyValue()) {
            destination.d->bottomRight = property;
        }
    }
}

ShadowProperty ShadowProperty::empty()
{
    ShadowProperty result;
    result.d->offsets = emptyValue<SizeProperty>();
    result.d->left = emptyValue<LineProperty>();
    result.d->right = emptyValue<LineProperty>();
    result.d->top = emptyValue<LineProperty>();
    result.d->bottom = emptyValue<LineProperty>();
    result.d->topLeft = emptyValue<CornerProperty>();
    result.d->topRight = emptyValue<CornerProperty>();
    result.d->bottomLeft = emptyValue<CornerProperty>();
    result.d->bottomRight = emptyValue<CornerProperty>();
    return result;
}

bool Union::Properties::operator==(const ShadowProperty &left, const ShadowProperty &right)
{
    if (left.offsets() != right.offsets()) {
        return false;
    }
    if (left.left() != right.left()) {
        return false;
    }
    if (left.right() != right.right()) {
        return false;
    }
    if (left.top() != right.top()) {
        return false;
    }
    if (left.bottom() != right.bottom()) {
        return false;
    }
    if (left.topLeft() != right.topLeft()) {
        return false;
    }
    if (left.topRight() != right.topRight()) {
        return false;
    }
    if (left.bottomLeft() != right.bottomLeft()) {
        return false;
    }
    if (left.bottomRight() != right.bottomRight()) {
        return false;
    }
    return true;
}

QDebug operator<<(QDebug debug, const Union::Properties::ShadowProperty &type)
{
    QDebugStateSaver saver(debug);
    debug.nospace() << "ShadowProperty(" //
                    << "offsets: " << type.offsets() //
                    << ", left: " << type.left() //
                    << ", right: " << type.right() //
                    << ", top: " << type.top() //
                    << ", bottom: " << type.bottom() //
                    << ", topLeft: " << type.topLeft() //
                    << ", topRight: " << type.topRight() //
                    << ", bottomLeft: " << type.bottomLeft() //
                    << ", bottomRight: " << type.bottomRight() //
                    << ")";
    return debug;
}