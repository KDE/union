// SPDX-License-Identifier: LGPL-2.1-only OR LGPL-3.0-only OR LicenseRef-KDE-Accepted-LGPL
//
// This file is automatically generated. To regenerate, run `tools/propertygenerator/generate_properties.py`.

#include "PaletteProperty.h"

using namespace Union::Properties;
using namespace Qt::StringLiterals;

class Union::Properties::PalettePropertyPrivate
{
public:
    std::optional<QColor> foreground;
    std::optional<QColor> background;
    std::optional<QColor> decoration;
};

PaletteProperty::PaletteProperty()
    : d(std::make_unique<PalettePropertyPrivate>())
{
}

PaletteProperty::PaletteProperty(const PaletteProperty &other)
    : d(std::make_unique<PalettePropertyPrivate>())
{
    d->foreground = other.d->foreground;
    d->background = other.d->background;
    d->decoration = other.d->decoration;
}

PaletteProperty::PaletteProperty(PaletteProperty &&other)
    : d(std::move(other.d))
{
}

PaletteProperty::~PaletteProperty() = default;

PaletteProperty &PaletteProperty::operator=(const PaletteProperty &other)
{
    if (this != &other) {
        d->foreground = other.d->foreground;
        d->background = other.d->background;
        d->decoration = other.d->decoration;
    }
    return *this;
}

PaletteProperty &PaletteProperty::operator=(PaletteProperty &&other)
{
    std::swap(d, other.d);
    return *this;
}

std::optional<QColor> PaletteProperty::foreground() const
{
    return d->foreground;
}

void PaletteProperty::setForeground(const std::optional<QColor> &newValue)
{
    if (newValue == d->foreground) {
        return;
    }

    d->foreground = newValue;
}
std::optional<QColor> PaletteProperty::background() const
{
    return d->background;
}

void PaletteProperty::setBackground(const std::optional<QColor> &newValue)
{
    if (newValue == d->background) {
        return;
    }

    d->background = newValue;
}
std::optional<QColor> PaletteProperty::decoration() const
{
    return d->decoration;
}

void PaletteProperty::setDecoration(const std::optional<QColor> &newValue)
{
    if (newValue == d->decoration) {
        return;
    }

    d->decoration = newValue;
}

bool PaletteProperty::hasAnyValue() const
{
    if (d->foreground.has_value()) {
        return true;
    }
    if (d->background.has_value()) {
        return true;
    }
    if (d->decoration.has_value()) {
        return true;
    }
    return false;
}

void PaletteProperty::resolveProperties(const PaletteProperty &source, PaletteProperty &destination)
{
    if (!destination.d->foreground.has_value()) {
        destination.d->foreground = source.d->foreground;
    }
    if (!destination.d->background.has_value()) {
        destination.d->background = source.d->background;
    }
    if (!destination.d->decoration.has_value()) {
        destination.d->decoration = source.d->decoration;
    }
}

bool Union::Properties::operator==(const PaletteProperty &left, const PaletteProperty &right)
{
    if (left.foreground() != right.foreground()) {
        return false;
    }
    if (left.background() != right.background()) {
        return false;
    }
    if (left.decoration() != right.decoration()) {
        return false;
    }
    return true;
}

QDebug operator<<(QDebug debug, const Union::Properties::PaletteProperty &type)
{
    QDebugStateSaver saver(debug);
    debug << "PaletteProperty(";
    debug << "  foreground:" << type.foreground();
    debug << "  background:" << type.background();
    debug << "  decoration:" << type.decoration();
    debug << ")";
    return debug;
}