// SPDX-License-Identifier: LGPL-2.1-only OR LGPL-3.0-only OR LicenseRef-KDE-Accepted-LGPL
//
// This file is automatically generated. To regenerate, run `tools/propertygenerator/generate_properties.py`.

#include "PaletteProperty.h"

#include "PropertiesTypes.h"

using namespace Union::Properties;
using namespace Qt::StringLiterals;

class Union::Properties::PalettePropertyPrivate
{
public:
    std::optional<QColor> accent;
    std::optional<QColor> alternateBase;
    std::optional<QColor> base;
    std::optional<QColor> brightText;
    std::optional<QColor> button;
    std::optional<QColor> buttonText;
    std::optional<QColor> dark;
    std::optional<QColor> highlight;
    std::optional<QColor> highlightedText;
    std::optional<QColor> light;
    std::optional<QColor> link;
    std::optional<QColor> linkVisited;
    std::optional<QColor> mid;
    std::optional<QColor> midlight;
    std::optional<QColor> placeholderText;
    std::optional<QColor> shadow;
    std::optional<QColor> text;
    std::optional<QColor> toolTipBase;
    std::optional<QColor> toolTipText;
    std::optional<QColor> window;
    std::optional<QColor> windowText;
    std::optional<QColor> positive;
    std::optional<QColor> neutral;
    std::optional<QColor> negative;
};

PaletteProperty::PaletteProperty()
    : d(std::make_unique<PalettePropertyPrivate>())
{
}

PaletteProperty::PaletteProperty(const PaletteProperty &other)
    : d(std::make_unique<PalettePropertyPrivate>())
{
    d->accent = other.d->accent;
    d->alternateBase = other.d->alternateBase;
    d->base = other.d->base;
    d->brightText = other.d->brightText;
    d->button = other.d->button;
    d->buttonText = other.d->buttonText;
    d->dark = other.d->dark;
    d->highlight = other.d->highlight;
    d->highlightedText = other.d->highlightedText;
    d->light = other.d->light;
    d->link = other.d->link;
    d->linkVisited = other.d->linkVisited;
    d->mid = other.d->mid;
    d->midlight = other.d->midlight;
    d->placeholderText = other.d->placeholderText;
    d->shadow = other.d->shadow;
    d->text = other.d->text;
    d->toolTipBase = other.d->toolTipBase;
    d->toolTipText = other.d->toolTipText;
    d->window = other.d->window;
    d->windowText = other.d->windowText;
    d->positive = other.d->positive;
    d->neutral = other.d->neutral;
    d->negative = other.d->negative;
}

PaletteProperty::PaletteProperty(PaletteProperty &&other)
    : d(std::move(other.d))
{
}

PaletteProperty::~PaletteProperty() = default;

PaletteProperty &PaletteProperty::operator=(const PaletteProperty &other)
{
    if (this != &other) {
        d->accent = other.d->accent;
        d->alternateBase = other.d->alternateBase;
        d->base = other.d->base;
        d->brightText = other.d->brightText;
        d->button = other.d->button;
        d->buttonText = other.d->buttonText;
        d->dark = other.d->dark;
        d->highlight = other.d->highlight;
        d->highlightedText = other.d->highlightedText;
        d->light = other.d->light;
        d->link = other.d->link;
        d->linkVisited = other.d->linkVisited;
        d->mid = other.d->mid;
        d->midlight = other.d->midlight;
        d->placeholderText = other.d->placeholderText;
        d->shadow = other.d->shadow;
        d->text = other.d->text;
        d->toolTipBase = other.d->toolTipBase;
        d->toolTipText = other.d->toolTipText;
        d->window = other.d->window;
        d->windowText = other.d->windowText;
        d->positive = other.d->positive;
        d->neutral = other.d->neutral;
        d->negative = other.d->negative;
    }
    return *this;
}

PaletteProperty &PaletteProperty::operator=(PaletteProperty &&other)
{
    std::swap(d, other.d);
    return *this;
}

std::optional<QColor> PaletteProperty::accent() const
{
    return d->accent;
}

void PaletteProperty::setAccent(const std::optional<QColor> &newValue)
{
    if (newValue == d->accent) {
        return;
    }

    d->accent = newValue;
}
std::optional<QColor> PaletteProperty::alternateBase() const
{
    return d->alternateBase;
}

void PaletteProperty::setAlternateBase(const std::optional<QColor> &newValue)
{
    if (newValue == d->alternateBase) {
        return;
    }

    d->alternateBase = newValue;
}
std::optional<QColor> PaletteProperty::base() const
{
    return d->base;
}

void PaletteProperty::setBase(const std::optional<QColor> &newValue)
{
    if (newValue == d->base) {
        return;
    }

    d->base = newValue;
}
std::optional<QColor> PaletteProperty::brightText() const
{
    return d->brightText;
}

void PaletteProperty::setBrightText(const std::optional<QColor> &newValue)
{
    if (newValue == d->brightText) {
        return;
    }

    d->brightText = newValue;
}
std::optional<QColor> PaletteProperty::button() const
{
    return d->button;
}

void PaletteProperty::setButton(const std::optional<QColor> &newValue)
{
    if (newValue == d->button) {
        return;
    }

    d->button = newValue;
}
std::optional<QColor> PaletteProperty::buttonText() const
{
    return d->buttonText;
}

void PaletteProperty::setButtonText(const std::optional<QColor> &newValue)
{
    if (newValue == d->buttonText) {
        return;
    }

    d->buttonText = newValue;
}
std::optional<QColor> PaletteProperty::dark() const
{
    return d->dark;
}

void PaletteProperty::setDark(const std::optional<QColor> &newValue)
{
    if (newValue == d->dark) {
        return;
    }

    d->dark = newValue;
}
std::optional<QColor> PaletteProperty::highlight() const
{
    return d->highlight;
}

void PaletteProperty::setHighlight(const std::optional<QColor> &newValue)
{
    if (newValue == d->highlight) {
        return;
    }

    d->highlight = newValue;
}
std::optional<QColor> PaletteProperty::highlightedText() const
{
    return d->highlightedText;
}

void PaletteProperty::setHighlightedText(const std::optional<QColor> &newValue)
{
    if (newValue == d->highlightedText) {
        return;
    }

    d->highlightedText = newValue;
}
std::optional<QColor> PaletteProperty::light() const
{
    return d->light;
}

void PaletteProperty::setLight(const std::optional<QColor> &newValue)
{
    if (newValue == d->light) {
        return;
    }

    d->light = newValue;
}
std::optional<QColor> PaletteProperty::link() const
{
    return d->link;
}

void PaletteProperty::setLink(const std::optional<QColor> &newValue)
{
    if (newValue == d->link) {
        return;
    }

    d->link = newValue;
}
std::optional<QColor> PaletteProperty::linkVisited() const
{
    return d->linkVisited;
}

void PaletteProperty::setLinkVisited(const std::optional<QColor> &newValue)
{
    if (newValue == d->linkVisited) {
        return;
    }

    d->linkVisited = newValue;
}
std::optional<QColor> PaletteProperty::mid() const
{
    return d->mid;
}

void PaletteProperty::setMid(const std::optional<QColor> &newValue)
{
    if (newValue == d->mid) {
        return;
    }

    d->mid = newValue;
}
std::optional<QColor> PaletteProperty::midlight() const
{
    return d->midlight;
}

void PaletteProperty::setMidlight(const std::optional<QColor> &newValue)
{
    if (newValue == d->midlight) {
        return;
    }

    d->midlight = newValue;
}
std::optional<QColor> PaletteProperty::placeholderText() const
{
    return d->placeholderText;
}

void PaletteProperty::setPlaceholderText(const std::optional<QColor> &newValue)
{
    if (newValue == d->placeholderText) {
        return;
    }

    d->placeholderText = newValue;
}
std::optional<QColor> PaletteProperty::shadow() const
{
    return d->shadow;
}

void PaletteProperty::setShadow(const std::optional<QColor> &newValue)
{
    if (newValue == d->shadow) {
        return;
    }

    d->shadow = newValue;
}
std::optional<QColor> PaletteProperty::text() const
{
    return d->text;
}

void PaletteProperty::setText(const std::optional<QColor> &newValue)
{
    if (newValue == d->text) {
        return;
    }

    d->text = newValue;
}
std::optional<QColor> PaletteProperty::toolTipBase() const
{
    return d->toolTipBase;
}

void PaletteProperty::setToolTipBase(const std::optional<QColor> &newValue)
{
    if (newValue == d->toolTipBase) {
        return;
    }

    d->toolTipBase = newValue;
}
std::optional<QColor> PaletteProperty::toolTipText() const
{
    return d->toolTipText;
}

void PaletteProperty::setToolTipText(const std::optional<QColor> &newValue)
{
    if (newValue == d->toolTipText) {
        return;
    }

    d->toolTipText = newValue;
}
std::optional<QColor> PaletteProperty::window() const
{
    return d->window;
}

void PaletteProperty::setWindow(const std::optional<QColor> &newValue)
{
    if (newValue == d->window) {
        return;
    }

    d->window = newValue;
}
std::optional<QColor> PaletteProperty::windowText() const
{
    return d->windowText;
}

void PaletteProperty::setWindowText(const std::optional<QColor> &newValue)
{
    if (newValue == d->windowText) {
        return;
    }

    d->windowText = newValue;
}
std::optional<QColor> PaletteProperty::positive() const
{
    return d->positive;
}

void PaletteProperty::setPositive(const std::optional<QColor> &newValue)
{
    if (newValue == d->positive) {
        return;
    }

    d->positive = newValue;
}
std::optional<QColor> PaletteProperty::neutral() const
{
    return d->neutral;
}

void PaletteProperty::setNeutral(const std::optional<QColor> &newValue)
{
    if (newValue == d->neutral) {
        return;
    }

    d->neutral = newValue;
}
std::optional<QColor> PaletteProperty::negative() const
{
    return d->negative;
}

void PaletteProperty::setNegative(const std::optional<QColor> &newValue)
{
    if (newValue == d->negative) {
        return;
    }

    d->negative = newValue;
}

bool PaletteProperty::hasAnyValue() const
{
    if (d->accent.has_value()) {
        return true;
    }
    if (d->alternateBase.has_value()) {
        return true;
    }
    if (d->base.has_value()) {
        return true;
    }
    if (d->brightText.has_value()) {
        return true;
    }
    if (d->button.has_value()) {
        return true;
    }
    if (d->buttonText.has_value()) {
        return true;
    }
    if (d->dark.has_value()) {
        return true;
    }
    if (d->highlight.has_value()) {
        return true;
    }
    if (d->highlightedText.has_value()) {
        return true;
    }
    if (d->light.has_value()) {
        return true;
    }
    if (d->link.has_value()) {
        return true;
    }
    if (d->linkVisited.has_value()) {
        return true;
    }
    if (d->mid.has_value()) {
        return true;
    }
    if (d->midlight.has_value()) {
        return true;
    }
    if (d->placeholderText.has_value()) {
        return true;
    }
    if (d->shadow.has_value()) {
        return true;
    }
    if (d->text.has_value()) {
        return true;
    }
    if (d->toolTipBase.has_value()) {
        return true;
    }
    if (d->toolTipText.has_value()) {
        return true;
    }
    if (d->window.has_value()) {
        return true;
    }
    if (d->windowText.has_value()) {
        return true;
    }
    if (d->positive.has_value()) {
        return true;
    }
    if (d->neutral.has_value()) {
        return true;
    }
    if (d->negative.has_value()) {
        return true;
    }
    return false;
}

void PaletteProperty::resolveProperties(const PaletteProperty &source, PaletteProperty &destination)
{
    if (!destination.d->accent.has_value()) {
        destination.d->accent = source.d->accent;
    }
    if (!destination.d->alternateBase.has_value()) {
        destination.d->alternateBase = source.d->alternateBase;
    }
    if (!destination.d->base.has_value()) {
        destination.d->base = source.d->base;
    }
    if (!destination.d->brightText.has_value()) {
        destination.d->brightText = source.d->brightText;
    }
    if (!destination.d->button.has_value()) {
        destination.d->button = source.d->button;
    }
    if (!destination.d->buttonText.has_value()) {
        destination.d->buttonText = source.d->buttonText;
    }
    if (!destination.d->dark.has_value()) {
        destination.d->dark = source.d->dark;
    }
    if (!destination.d->highlight.has_value()) {
        destination.d->highlight = source.d->highlight;
    }
    if (!destination.d->highlightedText.has_value()) {
        destination.d->highlightedText = source.d->highlightedText;
    }
    if (!destination.d->light.has_value()) {
        destination.d->light = source.d->light;
    }
    if (!destination.d->link.has_value()) {
        destination.d->link = source.d->link;
    }
    if (!destination.d->linkVisited.has_value()) {
        destination.d->linkVisited = source.d->linkVisited;
    }
    if (!destination.d->mid.has_value()) {
        destination.d->mid = source.d->mid;
    }
    if (!destination.d->midlight.has_value()) {
        destination.d->midlight = source.d->midlight;
    }
    if (!destination.d->placeholderText.has_value()) {
        destination.d->placeholderText = source.d->placeholderText;
    }
    if (!destination.d->shadow.has_value()) {
        destination.d->shadow = source.d->shadow;
    }
    if (!destination.d->text.has_value()) {
        destination.d->text = source.d->text;
    }
    if (!destination.d->toolTipBase.has_value()) {
        destination.d->toolTipBase = source.d->toolTipBase;
    }
    if (!destination.d->toolTipText.has_value()) {
        destination.d->toolTipText = source.d->toolTipText;
    }
    if (!destination.d->window.has_value()) {
        destination.d->window = source.d->window;
    }
    if (!destination.d->windowText.has_value()) {
        destination.d->windowText = source.d->windowText;
    }
    if (!destination.d->positive.has_value()) {
        destination.d->positive = source.d->positive;
    }
    if (!destination.d->neutral.has_value()) {
        destination.d->neutral = source.d->neutral;
    }
    if (!destination.d->negative.has_value()) {
        destination.d->negative = source.d->negative;
    }
}

PaletteProperty PaletteProperty::empty()
{
    PaletteProperty result;
    result.d->accent = emptyValue<QColor>();
    result.d->alternateBase = emptyValue<QColor>();
    result.d->base = emptyValue<QColor>();
    result.d->brightText = emptyValue<QColor>();
    result.d->button = emptyValue<QColor>();
    result.d->buttonText = emptyValue<QColor>();
    result.d->dark = emptyValue<QColor>();
    result.d->highlight = emptyValue<QColor>();
    result.d->highlightedText = emptyValue<QColor>();
    result.d->light = emptyValue<QColor>();
    result.d->link = emptyValue<QColor>();
    result.d->linkVisited = emptyValue<QColor>();
    result.d->mid = emptyValue<QColor>();
    result.d->midlight = emptyValue<QColor>();
    result.d->placeholderText = emptyValue<QColor>();
    result.d->shadow = emptyValue<QColor>();
    result.d->text = emptyValue<QColor>();
    result.d->toolTipBase = emptyValue<QColor>();
    result.d->toolTipText = emptyValue<QColor>();
    result.d->window = emptyValue<QColor>();
    result.d->windowText = emptyValue<QColor>();
    result.d->positive = emptyValue<QColor>();
    result.d->neutral = emptyValue<QColor>();
    result.d->negative = emptyValue<QColor>();
    return result;
}

bool Union::Properties::operator==(const PaletteProperty &left, const PaletteProperty &right)
{
    if (left.accent() != right.accent()) {
        return false;
    }
    if (left.alternateBase() != right.alternateBase()) {
        return false;
    }
    if (left.base() != right.base()) {
        return false;
    }
    if (left.brightText() != right.brightText()) {
        return false;
    }
    if (left.button() != right.button()) {
        return false;
    }
    if (left.buttonText() != right.buttonText()) {
        return false;
    }
    if (left.dark() != right.dark()) {
        return false;
    }
    if (left.highlight() != right.highlight()) {
        return false;
    }
    if (left.highlightedText() != right.highlightedText()) {
        return false;
    }
    if (left.light() != right.light()) {
        return false;
    }
    if (left.link() != right.link()) {
        return false;
    }
    if (left.linkVisited() != right.linkVisited()) {
        return false;
    }
    if (left.mid() != right.mid()) {
        return false;
    }
    if (left.midlight() != right.midlight()) {
        return false;
    }
    if (left.placeholderText() != right.placeholderText()) {
        return false;
    }
    if (left.shadow() != right.shadow()) {
        return false;
    }
    if (left.text() != right.text()) {
        return false;
    }
    if (left.toolTipBase() != right.toolTipBase()) {
        return false;
    }
    if (left.toolTipText() != right.toolTipText()) {
        return false;
    }
    if (left.window() != right.window()) {
        return false;
    }
    if (left.windowText() != right.windowText()) {
        return false;
    }
    if (left.positive() != right.positive()) {
        return false;
    }
    if (left.neutral() != right.neutral()) {
        return false;
    }
    if (left.negative() != right.negative()) {
        return false;
    }
    return true;
}

QDebug operator<<(QDebug debug, const Union::Properties::PaletteProperty &type)
{
    QDebugStateSaver saver(debug);
    debug.nospace() << "PaletteProperty(" //
                    << "accent: " << type.accent() //
                    << ", alternateBase: " << type.alternateBase() //
                    << ", base: " << type.base() //
                    << ", brightText: " << type.brightText() //
                    << ", button: " << type.button() //
                    << ", buttonText: " << type.buttonText() //
                    << ", dark: " << type.dark() //
                    << ", highlight: " << type.highlight() //
                    << ", highlightedText: " << type.highlightedText() //
                    << ", light: " << type.light() //
                    << ", link: " << type.link() //
                    << ", linkVisited: " << type.linkVisited() //
                    << ", mid: " << type.mid() //
                    << ", midlight: " << type.midlight() //
                    << ", placeholderText: " << type.placeholderText() //
                    << ", shadow: " << type.shadow() //
                    << ", text: " << type.text() //
                    << ", toolTipBase: " << type.toolTipBase() //
                    << ", toolTipText: " << type.toolTipText() //
                    << ", window: " << type.window() //
                    << ", windowText: " << type.windowText() //
                    << ", positive: " << type.positive() //
                    << ", neutral: " << type.neutral() //
                    << ", negative: " << type.negative() //
                    << ")";
    return debug;
}