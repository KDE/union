// SPDX-License-Identifier: LGPL-2.1-only OR LGPL-3.0-only OR LicenseRef-KDE-Accepted-LGPL
// SPDX-FileCopyrightText: 2024 Arjen Hiemstra <ahiemstra@heimr.nl>
//
// This file is automatically generated from formatter.h.j2.
// To regenerate, run `tools/propertygenerator/generate_properties.py`.

#pragma once

#include <format>

#include <properties/AlignmentProperty.h>
#include <properties/BackgroundProperty.h>
#include <properties/BorderProperty.h>
#include <properties/CornerProperty.h>
#include <properties/CornersProperty.h>
#include <properties/IconProperty.h>
#include <properties/ImageProperty.h>
#include <properties/LayoutProperty.h>
#include <properties/LineProperty.h>
#include <properties/PaletteProperty.h>
#include <properties/ShadowProperty.h>
#include <properties/SizeProperty.h>
#include <properties/StyleProperty.h>
#include <properties/TextProperty.h>

namespace
{
inline static std::string whitespace(std::size_t(1024), ' ');
}

std::string_view indent(int amount)
{
    return std::string_view(whitespace.begin(), whitespace.begin() + amount);
}

template<typename T>
struct std::formatter<std::optional<T>, char> {
    std::string content_format;

    template<class ParseContext>
    constexpr ParseContext::iterator parse(ParseContext &context)
    {
        auto itr = context.begin();
        while (itr != context.end() && *itr != '}') {
            itr++;
        }
        content_format = std::string(context.begin(), itr);
        return itr;
    }

    template<class FormatContext>
    FormatContext::iterator format(const std::optional<T> &value, FormatContext &context) const
    {
        if (value.has_value()) {
            return std::vformat_to(context.out(), "{0:" + content_format + "}", std::make_format_args(value.value()));
        } else {
            return std::ranges::copy("(empty)", context.out()).out;
        }
    }
};

template<>
struct std::formatter<QColor, char> : public std::formatter<std::string, char> {
    template<class FormatContext>
    FormatContext::iterator format(QColor value, FormatContext &context) const
    {
        return std::formatter<std::string, char>::format(value.name().toStdString(), context);
    }
};

template<>
struct std::formatter<QFont, char> : public std::formatter<std::string, char> {
    template<class FormatContext>
    FormatContext::iterator format(QFont value, FormatContext &context) const
    {
        return std::formatter<std::string, char>::format(value.toString().toStdString(), context);
    }
};

template<>
struct std::formatter<QString, char> : public std::formatter<std::string, char> {
    template<class FormatContext>
    FormatContext::iterator format(QString value, FormatContext &context) const
    {
        return std::formatter<std::string, char>::format(value.toStdString(), context);
    }
};

template<>
struct std::formatter<QUrl, char> : public std::formatter<std::string, char> {
    template<class FormatContext>
    FormatContext::iterator format(QUrl value, FormatContext &context) const
    {
        return std::formatter<std::string, char>::format(value.toString().toStdString(), context);
    }
};

template<>
struct std::formatter<QImage, char> : public std::formatter<std::string, char> {
    template<class FormatContext>
    FormatContext::iterator format(QImage value, FormatContext &context) const
    {
        auto metaEnum = QMetaEnum::fromType<QImage::Format>();
        auto tmp = std::format("QImage(fmt={0}, width={1}, height={2})", metaEnum.valueToKey(value.format()), value.width(), value.height());
        return std::formatter<std::string, char>::format(tmp, context);
    }
};

template<>
struct std::formatter<Qt::Alignment, char> : public std::formatter<std::string, char> {
    template<class FormatContext>
    FormatContext::iterator format(Qt::Alignment value, FormatContext &context) const
    {
        auto metaEnum = QMetaEnum::fromType<Qt::Alignment>();
        return std::formatter<std::string, char>::format(metaEnum.valueToKeys(value).toStdString(), context);
    }
};

template<typename T>
    requires std::is_enum_v<T>
struct std::formatter<T, char> : public std::formatter<std::string, char> {
    template<class FormatContext>
    FormatContext::iterator format(T value, FormatContext &context) const
    {
        auto metaEnum = QMetaEnum::fromType<T>();
        return std::formatter<std::string, char>::format(metaEnum.valueToKey(int(value)), context);
    }
};

template<typename T>
    requires std::is_enum_v<T>
struct std::formatter<QFlags<T>, char> : public std::formatter<std::string, char> {
    template<class FormatContext>
    FormatContext::iterator format(const QFlags<T> value, FormatContext &context) const
    {
        auto metaEnum = QMetaEnum::fromType<T>();
        return std::formatter<std::string, char>::format(metaEnum.valueToKeys(value).toStdString(), context);
    }
};

template<>
struct std::formatter<Union::Properties::StyleProperty, char> {
    bool use_newlines = false;
    int indentation = 0;

    template<class ParseContext>
    constexpr ParseContext::iterator parse(ParseContext &context)
    {
        std::string digits;

        auto itr = context.begin();
        while (itr != context.end() && *itr != '}') {
            if (*itr == 'n' && *(itr + 1) == 'l') {
                use_newlines = true;
            }

            if (*itr >= 48 && *itr <= 57) {
                indentation = indentation * 10 + (*itr - 48);
            }

            itr++;
        }

        return itr;
    }

    template<class FormatContext>
    FormatContext::iterator format(const Union::Properties::StyleProperty &property, FormatContext &context) const
    {
        std::ostringstream out;

        out << indent(indentation);
        out << "palette: ";
        {
            auto value = property.palette();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "layout: ";
        {
            auto value = property.layout();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "text: ";
        {
            auto value = property.text();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "icon: ";
        {
            auto value = property.icon();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "background: ";
        {
            auto value = property.background();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        return std::ranges::copy(std::move(out).str(), context.out()).out;
    }
};

template<>
struct std::formatter<Union::Properties::PaletteProperty, char> {
    bool use_newlines = false;
    int indentation = 0;

    template<class ParseContext>
    constexpr ParseContext::iterator parse(ParseContext &context)
    {
        std::string digits;

        auto itr = context.begin();
        while (itr != context.end() && *itr != '}') {
            if (*itr == 'n' && *(itr + 1) == 'l') {
                use_newlines = true;
            }

            if (*itr >= 48 && *itr <= 57) {
                indentation = indentation * 10 + (*itr - 48);
            }

            itr++;
        }

        return itr;
    }

    template<class FormatContext>
    FormatContext::iterator format(const Union::Properties::PaletteProperty &property, FormatContext &context) const
    {
        std::ostringstream out;

        out << indent(indentation);
        out << "accent: ";
        {
            auto value = property.accent();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "alternateBase: ";
        {
            auto value = property.alternateBase();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "base: ";
        {
            auto value = property.base();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "brightText: ";
        {
            auto value = property.brightText();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "button: ";
        {
            auto value = property.button();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "buttonText: ";
        {
            auto value = property.buttonText();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "dark: ";
        {
            auto value = property.dark();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "highlight: ";
        {
            auto value = property.highlight();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "highlightedText: ";
        {
            auto value = property.highlightedText();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "light: ";
        {
            auto value = property.light();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "link: ";
        {
            auto value = property.link();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "linkVisited: ";
        {
            auto value = property.linkVisited();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "mid: ";
        {
            auto value = property.mid();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "midlight: ";
        {
            auto value = property.midlight();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "placeholderText: ";
        {
            auto value = property.placeholderText();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "shadow: ";
        {
            auto value = property.shadow();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "text: ";
        {
            auto value = property.text();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "toolTipBase: ";
        {
            auto value = property.toolTipBase();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "toolTipText: ";
        {
            auto value = property.toolTipText();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "window: ";
        {
            auto value = property.window();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "windowText: ";
        {
            auto value = property.windowText();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "positive: ";
        {
            auto value = property.positive();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "neutral: ";
        {
            auto value = property.neutral();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "negative: ";
        {
            auto value = property.negative();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        return std::ranges::copy(std::move(out).str(), context.out()).out;
    }
};

template<>
struct std::formatter<Union::Properties::LayoutProperty, char> {
    bool use_newlines = false;
    int indentation = 0;

    template<class ParseContext>
    constexpr ParseContext::iterator parse(ParseContext &context)
    {
        std::string digits;

        auto itr = context.begin();
        while (itr != context.end() && *itr != '}') {
            if (*itr == 'n' && *(itr + 1) == 'l') {
                use_newlines = true;
            }

            if (*itr >= 48 && *itr <= 57) {
                indentation = indentation * 10 + (*itr - 48);
            }

            itr++;
        }

        return itr;
    }

    template<class FormatContext>
    FormatContext::iterator format(const Union::Properties::LayoutProperty &property, FormatContext &context) const
    {
        std::ostringstream out;

        out << indent(indentation);
        out << "alignment: ";
        {
            auto value = property.alignment();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "width: ";
        {
            auto value = property.width();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "height: ";
        {
            auto value = property.height();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "spacing: ";
        {
            auto value = property.spacing();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "padding: ";
        {
            auto value = property.padding();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "inset: ";
        {
            auto value = property.inset();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "margins: ";
        {
            auto value = property.margins();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        return std::ranges::copy(std::move(out).str(), context.out()).out;
    }
};

template<>
struct std::formatter<Union::Properties::AlignmentProperty, char> {
    bool use_newlines = false;
    int indentation = 0;

    template<class ParseContext>
    constexpr ParseContext::iterator parse(ParseContext &context)
    {
        std::string digits;

        auto itr = context.begin();
        while (itr != context.end() && *itr != '}') {
            if (*itr == 'n' && *(itr + 1) == 'l') {
                use_newlines = true;
            }

            if (*itr >= 48 && *itr <= 57) {
                indentation = indentation * 10 + (*itr - 48);
            }

            itr++;
        }

        return itr;
    }

    template<class FormatContext>
    FormatContext::iterator format(const Union::Properties::AlignmentProperty &property, FormatContext &context) const
    {
        std::ostringstream out;

        out << indent(indentation);
        out << "container: ";
        {
            auto value = property.container();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "horizontal: ";
        {
            auto value = property.horizontal();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "vertical: ";
        {
            auto value = property.vertical();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "order: ";
        {
            auto value = property.order();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        return std::ranges::copy(std::move(out).str(), context.out()).out;
    }
};

template<>
struct std::formatter<Union::Properties::SizeProperty, char> {
    bool use_newlines = false;
    int indentation = 0;

    template<class ParseContext>
    constexpr ParseContext::iterator parse(ParseContext &context)
    {
        std::string digits;

        auto itr = context.begin();
        while (itr != context.end() && *itr != '}') {
            if (*itr == 'n' && *(itr + 1) == 'l') {
                use_newlines = true;
            }

            if (*itr >= 48 && *itr <= 57) {
                indentation = indentation * 10 + (*itr - 48);
            }

            itr++;
        }

        return itr;
    }

    template<class FormatContext>
    FormatContext::iterator format(const Union::Properties::SizeProperty &property, FormatContext &context) const
    {
        std::ostringstream out;

        out << indent(indentation);
        out << "left: ";
        {
            auto value = property.left();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "right: ";
        {
            auto value = property.right();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "top: ";
        {
            auto value = property.top();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "bottom: ";
        {
            auto value = property.bottom();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        return std::ranges::copy(std::move(out).str(), context.out()).out;
    }
};

template<>
struct std::formatter<Union::Properties::TextProperty, char> {
    bool use_newlines = false;
    int indentation = 0;

    template<class ParseContext>
    constexpr ParseContext::iterator parse(ParseContext &context)
    {
        std::string digits;

        auto itr = context.begin();
        while (itr != context.end() && *itr != '}') {
            if (*itr == 'n' && *(itr + 1) == 'l') {
                use_newlines = true;
            }

            if (*itr >= 48 && *itr <= 57) {
                indentation = indentation * 10 + (*itr - 48);
            }

            itr++;
        }

        return itr;
    }

    template<class FormatContext>
    FormatContext::iterator format(const Union::Properties::TextProperty &property, FormatContext &context) const
    {
        std::ostringstream out;

        out << indent(indentation);
        out << "alignment: ";
        {
            auto value = property.alignment();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "font: ";
        {
            auto value = property.font();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        return std::ranges::copy(std::move(out).str(), context.out()).out;
    }
};

template<>
struct std::formatter<Union::Properties::IconProperty, char> {
    bool use_newlines = false;
    int indentation = 0;

    template<class ParseContext>
    constexpr ParseContext::iterator parse(ParseContext &context)
    {
        std::string digits;

        auto itr = context.begin();
        while (itr != context.end() && *itr != '}') {
            if (*itr == 'n' && *(itr + 1) == 'l') {
                use_newlines = true;
            }

            if (*itr >= 48 && *itr <= 57) {
                indentation = indentation * 10 + (*itr - 48);
            }

            itr++;
        }

        return itr;
    }

    template<class FormatContext>
    FormatContext::iterator format(const Union::Properties::IconProperty &property, FormatContext &context) const
    {
        std::ostringstream out;

        out << indent(indentation);
        out << "alignment: ";
        {
            auto value = property.alignment();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "width: ";
        {
            auto value = property.width();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "height: ";
        {
            auto value = property.height();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "name: ";
        {
            auto value = property.name();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "source: ";
        {
            auto value = property.source();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        return std::ranges::copy(std::move(out).str(), context.out()).out;
    }
};

template<>
struct std::formatter<Union::Properties::BackgroundProperty, char> {
    bool use_newlines = false;
    int indentation = 0;

    template<class ParseContext>
    constexpr ParseContext::iterator parse(ParseContext &context)
    {
        std::string digits;

        auto itr = context.begin();
        while (itr != context.end() && *itr != '}') {
            if (*itr == 'n' && *(itr + 1) == 'l') {
                use_newlines = true;
            }

            if (*itr >= 48 && *itr <= 57) {
                indentation = indentation * 10 + (*itr - 48);
            }

            itr++;
        }

        return itr;
    }

    template<class FormatContext>
    FormatContext::iterator format(const Union::Properties::BackgroundProperty &property, FormatContext &context) const
    {
        std::ostringstream out;

        out << indent(indentation);
        out << "color: ";
        {
            auto value = property.color();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "image: ";
        {
            auto value = property.image();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "border: ";
        {
            auto value = property.border();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "corners: ";
        {
            auto value = property.corners();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "shadow: ";
        {
            auto value = property.shadow();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        return std::ranges::copy(std::move(out).str(), context.out()).out;
    }
};

template<>
struct std::formatter<Union::Properties::ImageProperty, char> {
    bool use_newlines = false;
    int indentation = 0;

    template<class ParseContext>
    constexpr ParseContext::iterator parse(ParseContext &context)
    {
        std::string digits;

        auto itr = context.begin();
        while (itr != context.end() && *itr != '}') {
            if (*itr == 'n' && *(itr + 1) == 'l') {
                use_newlines = true;
            }

            if (*itr >= 48 && *itr <= 57) {
                indentation = indentation * 10 + (*itr - 48);
            }

            itr++;
        }

        return itr;
    }

    template<class FormatContext>
    FormatContext::iterator format(const Union::Properties::ImageProperty &property, FormatContext &context) const
    {
        std::ostringstream out;

        out << indent(indentation);
        out << "imageData: ";
        {
            auto value = property.imageData();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "width: ";
        {
            auto value = property.width();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "height: ";
        {
            auto value = property.height();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "xOffset: ";
        {
            auto value = property.xOffset();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "yOffset: ";
        {
            auto value = property.yOffset();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "flags: ";
        {
            auto value = property.flags();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        return std::ranges::copy(std::move(out).str(), context.out()).out;
    }
};

template<>
struct std::formatter<Union::Properties::BorderProperty, char> {
    bool use_newlines = false;
    int indentation = 0;

    template<class ParseContext>
    constexpr ParseContext::iterator parse(ParseContext &context)
    {
        std::string digits;

        auto itr = context.begin();
        while (itr != context.end() && *itr != '}') {
            if (*itr == 'n' && *(itr + 1) == 'l') {
                use_newlines = true;
            }

            if (*itr >= 48 && *itr <= 57) {
                indentation = indentation * 10 + (*itr - 48);
            }

            itr++;
        }

        return itr;
    }

    template<class FormatContext>
    FormatContext::iterator format(const Union::Properties::BorderProperty &property, FormatContext &context) const
    {
        std::ostringstream out;

        out << indent(indentation);
        out << "left: ";
        {
            auto value = property.left();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "right: ";
        {
            auto value = property.right();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "top: ";
        {
            auto value = property.top();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "bottom: ";
        {
            auto value = property.bottom();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        return std::ranges::copy(std::move(out).str(), context.out()).out;
    }
};

template<>
struct std::formatter<Union::Properties::LineProperty, char> {
    bool use_newlines = false;
    int indentation = 0;

    template<class ParseContext>
    constexpr ParseContext::iterator parse(ParseContext &context)
    {
        std::string digits;

        auto itr = context.begin();
        while (itr != context.end() && *itr != '}') {
            if (*itr == 'n' && *(itr + 1) == 'l') {
                use_newlines = true;
            }

            if (*itr >= 48 && *itr <= 57) {
                indentation = indentation * 10 + (*itr - 48);
            }

            itr++;
        }

        return itr;
    }

    template<class FormatContext>
    FormatContext::iterator format(const Union::Properties::LineProperty &property, FormatContext &context) const
    {
        std::ostringstream out;

        out << indent(indentation);
        out << "size: ";
        {
            auto value = property.size();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "color: ";
        {
            auto value = property.color();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "style: ";
        {
            auto value = property.style();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "image: ";
        {
            auto value = property.image();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        return std::ranges::copy(std::move(out).str(), context.out()).out;
    }
};

template<>
struct std::formatter<Union::Properties::CornersProperty, char> {
    bool use_newlines = false;
    int indentation = 0;

    template<class ParseContext>
    constexpr ParseContext::iterator parse(ParseContext &context)
    {
        std::string digits;

        auto itr = context.begin();
        while (itr != context.end() && *itr != '}') {
            if (*itr == 'n' && *(itr + 1) == 'l') {
                use_newlines = true;
            }

            if (*itr >= 48 && *itr <= 57) {
                indentation = indentation * 10 + (*itr - 48);
            }

            itr++;
        }

        return itr;
    }

    template<class FormatContext>
    FormatContext::iterator format(const Union::Properties::CornersProperty &property, FormatContext &context) const
    {
        std::ostringstream out;

        out << indent(indentation);
        out << "topLeft: ";
        {
            auto value = property.topLeft();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "topRight: ";
        {
            auto value = property.topRight();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "bottomLeft: ";
        {
            auto value = property.bottomLeft();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "bottomRight: ";
        {
            auto value = property.bottomRight();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        return std::ranges::copy(std::move(out).str(), context.out()).out;
    }
};

template<>
struct std::formatter<Union::Properties::CornerProperty, char> {
    bool use_newlines = false;
    int indentation = 0;

    template<class ParseContext>
    constexpr ParseContext::iterator parse(ParseContext &context)
    {
        std::string digits;

        auto itr = context.begin();
        while (itr != context.end() && *itr != '}') {
            if (*itr == 'n' && *(itr + 1) == 'l') {
                use_newlines = true;
            }

            if (*itr >= 48 && *itr <= 57) {
                indentation = indentation * 10 + (*itr - 48);
            }

            itr++;
        }

        return itr;
    }

    template<class FormatContext>
    FormatContext::iterator format(const Union::Properties::CornerProperty &property, FormatContext &context) const
    {
        std::ostringstream out;

        out << indent(indentation);
        out << "radius: ";
        {
            auto value = property.radius();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "width: ";
        {
            auto value = property.width();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "height: ";
        {
            auto value = property.height();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "color: ";
        {
            auto value = property.color();
            if (use_newlines) {
                out << std::format("{}\n", value);
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "image: ";
        {
            auto value = property.image();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        return std::ranges::copy(std::move(out).str(), context.out()).out;
    }
};

template<>
struct std::formatter<Union::Properties::ShadowProperty, char> {
    bool use_newlines = false;
    int indentation = 0;

    template<class ParseContext>
    constexpr ParseContext::iterator parse(ParseContext &context)
    {
        std::string digits;

        auto itr = context.begin();
        while (itr != context.end() && *itr != '}') {
            if (*itr == 'n' && *(itr + 1) == 'l') {
                use_newlines = true;
            }

            if (*itr >= 48 && *itr <= 57) {
                indentation = indentation * 10 + (*itr - 48);
            }

            itr++;
        }

        return itr;
    }

    template<class FormatContext>
    FormatContext::iterator format(const Union::Properties::ShadowProperty &property, FormatContext &context) const
    {
        std::ostringstream out;

        out << indent(indentation);
        out << "offsets: ";
        {
            auto value = property.offsets();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "left: ";
        {
            auto value = property.left();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "right: ";
        {
            auto value = property.right();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "top: ";
        {
            auto value = property.top();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "bottom: ";
        {
            auto value = property.bottom();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "topLeft: ";
        {
            auto value = property.topLeft();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "topRight: ";
        {
            auto value = property.topRight();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "bottomLeft: ";
        {
            auto value = property.bottomLeft();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        out << indent(indentation);
        out << "bottomRight: ";
        {
            auto value = property.bottomRight();
            if (use_newlines) {
                if (value.has_value()) {
                    auto format_string = "\n{0:nl" + std::to_string(indentation + 2) + "}";
                    out << std::vformat(format_string, std::make_format_args(value));
                } else {
                    out << "(empty)\n";
                }
            } else {
                out << std::format("{} ", value);
            }
        }

        return std::ranges::copy(std::move(out).str(), context.out()).out;
    }
};

//