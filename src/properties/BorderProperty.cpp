// SPDX-License-Identifier: LGPL-2.1-only OR LGPL-3.0-only OR LicenseRef-KDE-Accepted-LGPL
//
// This file is automatically generated. To regenerate, run `generate_properties.py`.

#include "BorderProperty.h"

using namespace Union::Properties;
using namespace Qt::StringLiterals;

class Union::Properties::BorderPropertyPrivate
{
public:
    std::optional<LineProperty> left;
    std::optional<LineProperty> right;
    std::optional<LineProperty> top;
    std::optional<LineProperty> bottom;
};

BorderProperty::BorderProperty()
    : d(std::make_unique<BorderPropertyPrivate>())
{
}

BorderProperty::BorderProperty(const BorderProperty &other)
    : d(std::make_unique<BorderPropertyPrivate>())
{
    d->left = other.d->left;
    d->right = other.d->right;
    d->top = other.d->top;
    d->bottom = other.d->bottom;
}

BorderProperty::BorderProperty(BorderProperty &&other)
    : d(std::move(other.d))
{
}

BorderProperty::~BorderProperty() = default;

BorderProperty &BorderProperty::operator=(const BorderProperty &other)
{
    if (this != &other) {
        d->left = other.d->left;
        d->right = other.d->right;
        d->top = other.d->top;
        d->bottom = other.d->bottom;
    }
    return *this;
}

BorderProperty &BorderProperty::operator=(BorderProperty &&other)
{
    std::swap(d, other.d);
    return *this;
}

std::optional<LineProperty> BorderProperty::left() const
{
    return d->left;
}

void BorderProperty::setLeft(const std::optional<LineProperty> &newValue)
{
    if (newValue == d->left) {
        return;
    }

    d->left = newValue;
}
std::optional<LineProperty> BorderProperty::right() const
{
    return d->right;
}

void BorderProperty::setRight(const std::optional<LineProperty> &newValue)
{
    if (newValue == d->right) {
        return;
    }

    d->right = newValue;
}
std::optional<LineProperty> BorderProperty::top() const
{
    return d->top;
}

void BorderProperty::setTop(const std::optional<LineProperty> &newValue)
{
    if (newValue == d->top) {
        return;
    }

    d->top = newValue;
}
std::optional<LineProperty> BorderProperty::bottom() const
{
    return d->bottom;
}

void BorderProperty::setBottom(const std::optional<LineProperty> &newValue)
{
    if (newValue == d->bottom) {
        return;
    }

    d->bottom = newValue;
}

bool BorderProperty::hasAnyValue() const
{
    if (d->left.has_value() && d->left->hasAnyValue()) {
        return true;
    }
    if (d->right.has_value() && d->right->hasAnyValue()) {
        return true;
    }
    if (d->top.has_value() && d->top->hasAnyValue()) {
        return true;
    }
    if (d->bottom.has_value() && d->bottom->hasAnyValue()) {
        return true;
    }
    return false;
}

void BorderProperty::resolveProperties(const BorderProperty &source, BorderProperty &destination)
{
    if (source.d->left.has_value()) {
        LineProperty value;
        if (destination.d->left.has_value()) {
            value = destination.d->left.value();
        }
        LineProperty::resolveProperties(source.d->left.value(), value);
        if (value.hasAnyValue()) {
            destination.d->left = value;
        }
    }
    if (source.d->right.has_value()) {
        LineProperty value;
        if (destination.d->right.has_value()) {
            value = destination.d->right.value();
        }
        LineProperty::resolveProperties(source.d->right.value(), value);
        if (value.hasAnyValue()) {
            destination.d->right = value;
        }
    }
    if (source.d->top.has_value()) {
        LineProperty value;
        if (destination.d->top.has_value()) {
            value = destination.d->top.value();
        }
        LineProperty::resolveProperties(source.d->top.value(), value);
        if (value.hasAnyValue()) {
            destination.d->top = value;
        }
    }
    if (source.d->bottom.has_value()) {
        LineProperty value;
        if (destination.d->bottom.has_value()) {
            value = destination.d->bottom.value();
        }
        LineProperty::resolveProperties(source.d->bottom.value(), value);
        if (value.hasAnyValue()) {
            destination.d->bottom = value;
        }
    }
}

bool Union::Properties::operator==(const BorderProperty &left, const BorderProperty &right)
{
    if (left.left() != right.left()) {
        return false;
    }
    if (left.right() != right.right()) {
        return false;
    }
    if (left.top() != right.top()) {
        return false;
    }
    if (left.bottom() != right.bottom()) {
        return false;
    }
    return true;
}

QDebug operator<<(QDebug debug, const Union::Properties::BorderProperty &type)
{
    QDebugStateSaver saver(debug);
    debug << "BorderProperty(";
    debug << "  left:" << type.left();
    debug << "  right:" << type.right();
    debug << "  top:" << type.top();
    debug << "  bottom:" << type.bottom();
    debug << ")";
    return debug;
}