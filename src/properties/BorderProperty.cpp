// SPDX-License-Identifier: LGPL-2.1-only OR LGPL-3.0-only OR LicenseRef-KDE-Accepted-LGPL
//
// This file is automatically generated. To regenerate, run `generate_properties.py`.

#include "BorderProperty.h"

using namespace Union::Properties;
using namespace Qt::StringLiterals;

class Union::Properties::BorderPropertyPrivate
{
public:
    std::optional<qreal> size;
    std::optional<QColor> color;
    std::optional<Union::Properties::LineStyle> style;
    std::optional<ImageProperty> image;
};

BorderProperty::BorderProperty()
    : d(std::make_unique<BorderPropertyPrivate>())
{
}

BorderProperty::BorderProperty(const BorderProperty &other)
    : d(std::make_unique<BorderPropertyPrivate>())
{
    d->size = other.d->size;
    d->color = other.d->color;
    d->style = other.d->style;
    d->image = other.d->image;
}

BorderProperty::BorderProperty(BorderProperty &&other)
    : d(std::move(other.d))
{
}

BorderProperty::~BorderProperty() = default;

BorderProperty &BorderProperty::operator=(const BorderProperty &other)
{
    if (this != &other) {
        d->size = other.d->size;
        d->color = other.d->color;
        d->style = other.d->style;
        d->image = other.d->image;
    }
    return *this;
}

BorderProperty &BorderProperty::operator=(BorderProperty &&other)
{
    std::swap(d, other.d);
    return *this;
}

std::optional<qreal> BorderProperty::size() const
{
    return d->size;
}

void BorderProperty::setSize(const std::optional<qreal> &newValue)
{
    if (newValue == d->size) {
        return;
    }

    d->size = newValue;
}
std::optional<QColor> BorderProperty::color() const
{
    return d->color;
}

void BorderProperty::setColor(const std::optional<QColor> &newValue)
{
    if (newValue == d->color) {
        return;
    }

    d->color = newValue;
}
std::optional<Union::Properties::LineStyle> BorderProperty::style() const
{
    return d->style;
}

void BorderProperty::setStyle(const std::optional<Union::Properties::LineStyle> &newValue)
{
    if (newValue == d->style) {
        return;
    }

    d->style = newValue;
}
std::optional<ImageProperty> BorderProperty::image() const
{
    return d->image;
}

void BorderProperty::setImage(const std::optional<ImageProperty> &newValue)
{
    if (newValue == d->image) {
        return;
    }

    d->image = newValue;
}

bool BorderProperty::hasAnyValue() const
{
    if (d->size.has_value()) {
        return true;
    }
    if (d->color.has_value()) {
        return true;
    }
    if (d->style.has_value()) {
        return true;
    }
    if (d->image.has_value() && d->image->hasAnyValue()) {
        return true;
    }
    return false;
}

void BorderProperty::resolveProperties(const BorderProperty &source, BorderProperty &destination)
{
    if (!destination.d->size.has_value()) {
        destination.d->size = source.d->size;
    }
    if (!destination.d->color.has_value()) {
        destination.d->color = source.d->color;
    }
    if (!destination.d->style.has_value()) {
        destination.d->style = source.d->style;
    }
    if (source.d->image.has_value()) {
        ImageProperty value;
        if (destination.d->image.has_value()) {
            value = destination.d->image.value();
        }
        ImageProperty::resolveProperties(source.d->image.value(), value);
        if (value.hasAnyValue()) {
            destination.d->image = value;
        }
    }
}

bool Union::Properties::operator==(const BorderProperty &left, const BorderProperty &right)
{
    if (left.size() != right.size()) {
        return false;
    }
    if (left.color() != right.color()) {
        return false;
    }
    if (left.style() != right.style()) {
        return false;
    }
    if (left.image() != right.image()) {
        return false;
    }
    return true;
}

QDebug operator<<(QDebug debug, const Union::Properties::BorderProperty &type)
{
    QDebugStateSaver saver(debug);
    debug << "BorderProperty(";
    debug << "  size:" << type.size();
    debug << "  color:" << type.color();
    debug << "  style:" << type.style();
    debug << "  image:" << type.image();
    debug << ")";
    return debug;
}