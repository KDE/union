// SPDX-License-Identifier: LGPL-2.1-only OR LGPL-3.0-only OR LicenseRef-KDE-Accepted-LGPL
// SPDX-FileCopyrightText: 2024 Arjen Hiemstra <ahiemstra@heimr.nl>
//
// This file is automatically generated from property.cpp.j2.
// To regenerate, run `tools/propertygenerator/generate_properties.py`.

#include "OutlineProperty.h"

#include "PropertiesTypes.h"

using namespace Union::Properties;
using namespace Qt::StringLiterals;

class Union::Properties::OutlinePropertyPrivate
{
public:
    std::unique_ptr<LineProperty> left;
    std::unique_ptr<LineProperty> right;
    std::unique_ptr<LineProperty> top;
    std::unique_ptr<LineProperty> bottom;
};

OutlineProperty::OutlineProperty()
    : d(std::make_unique<OutlinePropertyPrivate>())
{
}

OutlineProperty::OutlineProperty(const OutlineProperty &other)
    : d(std::make_unique<OutlinePropertyPrivate>())
{
    d->left = std::make_unique<LineProperty>();
    *(d->left) = *(other.d->left);
    d->right = std::make_unique<LineProperty>();
    *(d->right) = *(other.d->right);
    d->top = std::make_unique<LineProperty>();
    *(d->top) = *(other.d->top);
    d->bottom = std::make_unique<LineProperty>();
    *(d->bottom) = *(other.d->bottom);
}

OutlineProperty::OutlineProperty(OutlineProperty &&other)
    : d(std::move(other.d))
{
}

OutlineProperty::~OutlineProperty() = default;

OutlineProperty &OutlineProperty::operator=(const OutlineProperty &other)
{
    if (this != &other) {
        *(d->left) = *(other.d->left);
        *(d->right) = *(other.d->right);
        *(d->top) = *(other.d->top);
        *(d->bottom) = *(other.d->bottom);
    }
    return *this;
}

OutlineProperty &OutlineProperty::operator=(OutlineProperty &&other)
{
    std::swap(d, other.d);
    return *this;
}

LineProperty *OutlineProperty::left() const
{
    return d->left.get();
}

void OutlineProperty::setLeft(std::unique_ptr<LineProperty> &&newValue)
{
    d->left = std::move(newValue);
}

LineProperty *OutlineProperty::right() const
{
    return d->right.get();
}

void OutlineProperty::setRight(std::unique_ptr<LineProperty> &&newValue)
{
    d->right = std::move(newValue);
}

LineProperty *OutlineProperty::top() const
{
    return d->top.get();
}

void OutlineProperty::setTop(std::unique_ptr<LineProperty> &&newValue)
{
    d->top = std::move(newValue);
}

LineProperty *OutlineProperty::bottom() const
{
    return d->bottom.get();
}

void OutlineProperty::setBottom(std::unique_ptr<LineProperty> &&newValue)
{
    d->bottom = std::move(newValue);
}

bool OutlineProperty::hasAnyValue() const
{
    if (d->left && d->left->hasAnyValue()) {
        return true;
    }
    if (d->right && d->right->hasAnyValue()) {
        return true;
    }
    if (d->top && d->top->hasAnyValue()) {
        return true;
    }
    if (d->bottom && d->bottom->hasAnyValue()) {
        return true;
    }
    return false;
}

bool OutlineProperty::isEmpty() const
{
    if (!hasAnyValue()) {
        return true;
    }

    if (d->left && !d->left->isEmpty()) {
        return false;
    }
    if (d->right && !d->right->isEmpty()) {
        return false;
    }
    if (d->top && !d->top->isEmpty()) {
        return false;
    }
    if (d->bottom && !d->bottom->isEmpty()) {
        return false;
    }

    return true;
}

void OutlineProperty::resolveProperties(const OutlineProperty *source, OutlineProperty *destination)
{
    if (!source || !destination) {
        return;
    }

    if (source->d->left) {
        if (!destination->d->left) {
            destination->d->left = std::make_unique<LineProperty>();
        }
        LineProperty::resolveProperties(source->d->left.get(), destination->d->left.get());
    }
    if (source->d->right) {
        if (!destination->d->right) {
            destination->d->right = std::make_unique<LineProperty>();
        }
        LineProperty::resolveProperties(source->d->right.get(), destination->d->right.get());
    }
    if (source->d->top) {
        if (!destination->d->top) {
            destination->d->top = std::make_unique<LineProperty>();
        }
        LineProperty::resolveProperties(source->d->top.get(), destination->d->top.get());
    }
    if (source->d->bottom) {
        if (!destination->d->bottom) {
            destination->d->bottom = std::make_unique<LineProperty>();
        }
        LineProperty::resolveProperties(source->d->bottom.get(), destination->d->bottom.get());
    }
}

std::unique_ptr<OutlineProperty> OutlineProperty::empty()
{
    auto result = std::make_unique<OutlineProperty>();
    result->d->left = LineProperty::empty();
    result->d->right = LineProperty::empty();
    result->d->top = LineProperty::empty();
    result->d->bottom = LineProperty::empty();
    return result;
}

bool Union::Properties::operator==(const OutlineProperty &left, const OutlineProperty &right)
{
    if (left.left() && right.left()) {
        if (*(left.left()) != *(right.left())) {
            return false;
        }
    } else if (left.left() != right.left()) {
        return false;
    }
    if (left.right() && right.right()) {
        if (*(left.right()) != *(right.right())) {
            return false;
        }
    } else if (left.right() != right.right()) {
        return false;
    }
    if (left.top() && right.top()) {
        if (*(left.top()) != *(right.top())) {
            return false;
        }
    } else if (left.top() != right.top()) {
        return false;
    }
    if (left.bottom() && right.bottom()) {
        if (*(left.bottom()) != *(right.bottom())) {
            return false;
        }
    } else if (left.bottom() != right.bottom()) {
        return false;
    }
    return true;
}

QDebug operator<<(QDebug debug, const Union::Properties::OutlineProperty &type)
{
    QDebugStateSaver saver(debug);
    debug.nospace() << "OutlineProperty(";
    if (type.left()) {
        debug.nospace() << "left: " << *type.left();
    } else {
        debug.nospace() << "left: (empty)";
    }
    if (type.right()) {
        debug.nospace() << ", right: " << *type.right();
    } else {
        debug.nospace() << ", right: (empty)";
    }
    if (type.top()) {
        debug.nospace() << ", top: " << *type.top();
    } else {
        debug.nospace() << ", top: (empty)";
    }
    if (type.bottom()) {
        debug.nospace() << ", bottom: " << *type.bottom();
    } else {
        debug.nospace() << ", bottom: (empty)";
    }
    debug.nospace() << ")";
    return debug;
}