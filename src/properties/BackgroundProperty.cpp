// SPDX-License-Identifier: LGPL-2.1-only OR LGPL-3.0-only OR LicenseRef-KDE-Accepted-LGPL
// SPDX-FileCopyrightText: 2024 Arjen Hiemstra <ahiemstra@heimr.nl>
//
// This file is automatically generated from property.cpp.j2.
// To regenerate, run `tools/propertygenerator/generate_properties.py`.

#include "BackgroundProperty.h"

#include "PropertiesTypes.h"

using namespace Union::Properties;
using namespace Qt::StringLiterals;

class Union::Properties::BackgroundPropertyPrivate
{
public:
    std::optional<QColor> color;
    std::optional<ImageProperty> image;
    std::optional<BorderProperty> border;
    std::optional<CornersProperty> corners;
    std::optional<ShadowProperty> shadow;
};

BackgroundProperty::BackgroundProperty()
    : d(std::make_unique<BackgroundPropertyPrivate>())
{
}

BackgroundProperty::BackgroundProperty(const BackgroundProperty &other)
    : d(std::make_unique<BackgroundPropertyPrivate>())
{
    d->color = other.d->color;
    d->image = other.d->image;
    d->border = other.d->border;
    d->corners = other.d->corners;
    d->shadow = other.d->shadow;
}

BackgroundProperty::BackgroundProperty(BackgroundProperty &&other)
    : d(std::move(other.d))
{
}

BackgroundProperty::~BackgroundProperty() = default;

BackgroundProperty &BackgroundProperty::operator=(const BackgroundProperty &other)
{
    if (this != &other) {
        d->color = other.d->color;
        d->image = other.d->image;
        d->border = other.d->border;
        d->corners = other.d->corners;
        d->shadow = other.d->shadow;
    }
    return *this;
}

BackgroundProperty &BackgroundProperty::operator=(BackgroundProperty &&other)
{
    std::swap(d, other.d);
    return *this;
}

std::optional<QColor> BackgroundProperty::color() const
{
    return d->color;
}

void BackgroundProperty::setColor(const std::optional<QColor> &newValue)
{
    if (newValue == d->color) {
        return;
    }

    d->color = newValue;
}
std::optional<ImageProperty> BackgroundProperty::image() const
{
    return d->image;
}

void BackgroundProperty::setImage(const std::optional<ImageProperty> &newValue)
{
    if (newValue == d->image) {
        return;
    }

    d->image = newValue;
}
std::optional<BorderProperty> BackgroundProperty::border() const
{
    return d->border;
}

void BackgroundProperty::setBorder(const std::optional<BorderProperty> &newValue)
{
    if (newValue == d->border) {
        return;
    }

    d->border = newValue;
}
std::optional<CornersProperty> BackgroundProperty::corners() const
{
    return d->corners;
}

void BackgroundProperty::setCorners(const std::optional<CornersProperty> &newValue)
{
    if (newValue == d->corners) {
        return;
    }

    d->corners = newValue;
}
std::optional<ShadowProperty> BackgroundProperty::shadow() const
{
    return d->shadow;
}

void BackgroundProperty::setShadow(const std::optional<ShadowProperty> &newValue)
{
    if (newValue == d->shadow) {
        return;
    }

    d->shadow = newValue;
}

bool BackgroundProperty::hasAnyValue() const
{
    if (d->color.has_value()) {
        return true;
    }
    if (d->image.has_value() && d->image->hasAnyValue()) {
        return true;
    }
    if (d->border.has_value() && d->border->hasAnyValue()) {
        return true;
    }
    if (d->corners.has_value() && d->corners->hasAnyValue()) {
        return true;
    }
    if (d->shadow.has_value() && d->shadow->hasAnyValue()) {
        return true;
    }
    return false;
}

void BackgroundProperty::resolveProperties(const BackgroundProperty &source, BackgroundProperty &destination)
{
    if (!destination.d->color.has_value()) {
        destination.d->color = source.d->color;
    }
    if (source.d->image.has_value()) {
        ImageProperty property;
        if (destination.d->image.has_value()) {
            property = destination.d->image.value();
        }
        ImageProperty::resolveProperties(source.d->image.value(), property);
        if (property.hasAnyValue()) {
            destination.d->image = property;
        }
    }
    if (source.d->border.has_value()) {
        BorderProperty property;
        if (destination.d->border.has_value()) {
            property = destination.d->border.value();
        }
        BorderProperty::resolveProperties(source.d->border.value(), property);
        if (property.hasAnyValue()) {
            destination.d->border = property;
        }
    }
    if (source.d->corners.has_value()) {
        CornersProperty property;
        if (destination.d->corners.has_value()) {
            property = destination.d->corners.value();
        }
        CornersProperty::resolveProperties(source.d->corners.value(), property);
        if (property.hasAnyValue()) {
            destination.d->corners = property;
        }
    }
    if (source.d->shadow.has_value()) {
        ShadowProperty property;
        if (destination.d->shadow.has_value()) {
            property = destination.d->shadow.value();
        }
        ShadowProperty::resolveProperties(source.d->shadow.value(), property);
        if (property.hasAnyValue()) {
            destination.d->shadow = property;
        }
    }
}

BackgroundProperty BackgroundProperty::empty()
{
    BackgroundProperty result;
    result.d->color = emptyValue<QColor>();
    result.d->image = emptyValue<ImageProperty>();
    result.d->border = emptyValue<BorderProperty>();
    result.d->corners = emptyValue<CornersProperty>();
    result.d->shadow = emptyValue<ShadowProperty>();
    return result;
}

bool Union::Properties::operator==(const BackgroundProperty &left, const BackgroundProperty &right)
{
    if (left.color() != right.color()) {
        return false;
    }
    if (left.image() != right.image()) {
        return false;
    }
    if (left.border() != right.border()) {
        return false;
    }
    if (left.corners() != right.corners()) {
        return false;
    }
    if (left.shadow() != right.shadow()) {
        return false;
    }
    return true;
}

QDebug operator<<(QDebug debug, const Union::Properties::BackgroundProperty &type)
{
    QDebugStateSaver saver(debug);
    debug.nospace() << "BackgroundProperty(" //
                    << "color: " << type.color() //
                    << ", image: " << type.image() //
                    << ", border: " << type.border() //
                    << ", corners: " << type.corners() //
                    << ", shadow: " << type.shadow() //
                    << ")";
    return debug;
}